#!/usr/bin/env bash
# shellcheck disable=SC1090,SC1091
set -o errexit    # Exit immediately if a command exits with a non-zero status (same as set -e)
set -o nounset    # Treat unset variables and parameters as an error (same as set -u)
set -o pipefail   # If any command in a pipeline fails, the pipeline returns an error code
set -o posix      # Enable POSIX mode for more portable behavior (may disable some Bash-specific extensions)
shopt -s nullglob # When no files match a glob pattern, expand to nothing instead of the pattern itself

WORK_DIR="$(dirname "$(readlink -f "$0")")"
source "${WORK_DIR}/func"

# if ! ${TSC_FUNC:-false}; then
#     source "${WORK_DIR}/func"
# fi

declare -gA registered_modules_map=()
declare -gA module_arg_indices=()
declare -g all_args=()

function load_registered_modules() {
    local modules_dir="${WORK_DIR}/modules"
    local module_names=()
    local module
    if [[ -d "${modules_dir}" ]]; then
        for dir in "${modules_dir}"/*/; do
            if [[ -f "${dir}/module.json" ]]; then
                module="$(basename "$dir")"
                module_names+=("$module")
                registered_modules_map["$module"]=1
            fi
        done
    fi
}

function is_valid_module() {
    local name="$1"
    [[ -n "${registered_modules_map[$name]:-}" ]] ||
        return 1
}

function parse_arguments_by_module() {
    local args=("$@")
    local i=0
    local current_module=""
    local i_start=0

    while ((i < ${#args[@]})); do
        local arg="${args[i]}"
        if [[ "$arg" == --* ]]; then
            local candidate="${arg#--}"
            if is_valid_module "${candidate}"; then
                if [[ -n "${current_module}" ]]; then
                    module_arg_indices["${current_module}"]="${i_start}"
                    module_arg_indices["${current_module}_end"]="$i"
                fi
                current_module="${candidate}"
                i_start="$i"
                i=$((i + 1))
                continue
            fi
        fi
        all_args+=("${arg}")
        i=$((i + 1))
    done

    if [[ -n "$current_module" ]]; then
        module_arg_indices["$current_module"]="$i_start"
        module_arg_indices["${current_module}_end"]="${#all_args[@]}"
    fi
    if [[ ${#module_arg_indices[@]} -eq 0 && ${#all_args[@]} -gt 0 ]]; then
        LOGERROR "Some arguments do not belong to any module."
        show_global_help
        exit 1
    fi
}

function run_module_with_args() {
    local module_name="$1"
    shift
    local args=("$@")
    local module_dir="${WORK_DIR}/modules/${module_name}"
    local script_path="${module_dir}/run.sh"

    if [[ -x "${script_path}" ]]; then
        LOGINFO "Running module: ${module_name}"
        "${script_path}" "${args[@]}"
    else
        LOGERROR "Module script not found or not executable: ${script_path}"
        exit 1
    fi
}

function read_module_metadata() {
    local module_name="$1"
    local module_dir="${WORK_DIR}/modules/${module_name}"
    local meta_file="${module_dir}/module.json"

    if [[ -f "${meta_file}" ]]; then
        jq . -r "${meta_file}"
    else
        return 1
    fi
}

function show_global_help() {
    echo "Usage:"
    echo " $(basename "$0") [--module] <module_args> <--module> <--module> <module_args>"
    echo ""
    echo "Available modules:"
    local meta title description

    for module in "${!registered_modules_map[@]}"; do
        meta=$(read_module_metadata "${module}" 2>/dev/null)
        title=$(echo "${meta}" | jq -r '.title // empty')
        description=$(echo "${meta}" | jq -r '.description // empty')
        usage=$(echo "${meta}" | jq -r '.usage // empty')
        echo "  --${module}"
        echo "      ${title}"
        echo "      ${description}"
        [[ -n "${usage}" ]] && echo "      ${usage}"
    done
}

function main() {
    load_registered_modules
    if [[ $# -eq 0 ]]; then
        show_global_help
        exit 0
    fi

    parse_arguments_by_module "$@"

    if [[ "$1" == "-h" ]] || [[ "$1" == "help" ]]; then
        show_global_help
        exit 0
    fi

    for module in "${!module_arg_indices[@]}"; do
        if [[ "$module" == *_end ]]; then
            continue
        fi
        local start=${module_arg_indices[$module]}
        local end=${module_arg_indices["${module}_end"]}
        local count=$((end - start))
        local module_args=("${all_args[@]:$start:$count}")
        run_module_with_args "$module" "${module_args[@]}"
    done
}

main "$@"
